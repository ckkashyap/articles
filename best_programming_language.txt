Best programming language!

Many may discount the idea of "best programming language" with "all
languages have positives and negetives and that no one language could
be the best". But I believe, given a set of criteria we could compare
various programming languages and attempt to figure out which one is
better in most criteria. I will attempt to do it in this article.

And to those who may say that "languages dont matter; algorithms do" -
I'll just say that COBOL is (was?) a programming language.

Just so you know where I am coming from - I am very familiar with C (I
have used it to implement x86 kernels) and Perl and have studied the
following languages - Haskell, Clojure, Go, Rust and Nim. (I'll leave
Java and C++ out of the discussion because they make me bitter). I
consider myself as a power vim user - I switched to Emacs about 4
years ago after being bitten by the functional bug.


Non criteria

1. Static vs Dynamic typing

One argument that supports Static typing is that it helps in proving
correctness. The argument against it is that one can only prove that
the types line up - whether the program is correct from the programmer
intention point of view is questionable. Second, it is argued that
static types help with refactoring. Again, to the extent of types
aligning. Remember

sum = foldr (-) 0

is correct Haskell code - as in it compiles.

The argument for dynamic type system, in my opinion is flawed - they
talk about "compiler does not come in the way" etc - as in, one is
allowed to write "incorrect code" and are told about it only at run
time.

Anyway, my point is - if you have to shoot for correctness - shoot for
a good design first. Design is a somewhat diluted term in the software
industry so I'll go with Rich Hickey's defintion - which is, I
paraphrase here - the art of breaking down a problem such that it can
be composed back. Essentially, your implementation must contain tiny
modules each of which do one thing. This, will help writing evident
code that is "obviously correct; instead of, without obvious
mistakes". The typesystem of the language per se does not help or come
in the way of design.

2. IDE support

I'm just saying that I am not considering that as a parameter for
language comparison.

3. Indentation level as block structure

I can totally get it if you hate the idea - like in Haskell, Python et
al. I myself did not like it one bit. After learning Haskell - it's
ideas were so good that I decided to live with the indentation thingy
- ofcourse, I quickly got over my dislike began to like it. So, it
does not seem like a valid basis for comparison of languages.



Criteria number 1a - Higher order function / Function as first class value

Lambda calculus is "Turing Complete" and it contains nothing more than
function definition and function application. There are plenty of
articles on the internet that demonstrate how, using just the
capability of function definition and function application, one could
build numerals, booleans etc

Even in "Why function programming matters", John Hughes demonstrated
how vital higher order functions are. Ofcourse, he also said that lazy
evaluation is vital - I disagree there since once can build "lazy
evaluation" once equiped with higher order functions [2].

Criteria number 1b - Macro support

If the word macro evokes "C macro" / "conditional compilation" in your
mind, your probably also believe macros are bad. On the other hand,
folks from LSIP side believe that macros give them that extra power
(super power).

In C and C++, macro


Criteria number 2 - Strict (Applicative order) evaluation

According to "Why Functional Programming Matters" - Lazy evaluation is
one of the two key features that is necessary for a language to
fascilitate modularity. The other feature being higher order
functions. Two points to keep in mind here

  1. Lazy evaluation can be implemented in strict languages -
  http://matt.might.net/articles/implementing-laziness/

  2. Laziness mixed with IO is unpleasant (to put it very mildly)


Criteria number 3 - Reach

These days I almost always have to deal with Mac, Linux and Windows and switch between them.

Criteria number 4 - Ability to target native and javascript



[1] http://matt.might.net/articles/implementing-laziness
[2] http://www.cs.kent.ac.uk/people/staff/dat/miranda /whyfp90.pdf
